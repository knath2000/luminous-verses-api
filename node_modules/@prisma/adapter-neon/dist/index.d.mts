import type { ConnectionInfo } from '@prisma/driver-adapter-utils';
import type { DriverAdapter } from '@prisma/driver-adapter-utils';
import * as neon from '@neondatabase/serverless';
import type { Query } from '@prisma/driver-adapter-utils';
import type { Queryable } from '@prisma/driver-adapter-utils';
import type { Result } from '@prisma/driver-adapter-utils';
import type { ResultSet } from '@prisma/driver-adapter-utils';
import type { TransactionContext } from '@prisma/driver-adapter-utils';

declare type ARRAY_MODE_ENABLED = true;

/**
 * Base class for http client, ws client and ws transaction
 */
declare abstract class NeonQueryable implements Queryable {
    readonly provider = "postgres";
    readonly adapterName: string;
    /**
     * Execute a query given as SQL, interpolating the given parameters.
     */
    queryRaw(query: Query): Promise<Result<ResultSet>>;
    /**
     * Execute a query given as SQL, interpolating the given parameters and
     * returning the number of affected rows.
     * Note: Queryable expects a u64, but napi.rs only supports u32.
     */
    executeRaw(query: Query): Promise<Result<number>>;
    /**
     * Run a query against the database, returning the result set.
     * Should the query fail due to a connection error, the connection is
     * marked as unhealthy.
     */
    abstract performIO(query: Query): Promise<Result<PerformIOResult>>;
}

/**
 * Base class for WS-based queryables: top-level client and transaction
 */
declare class NeonWsQueryable<ClientT extends neon.Pool | neon.PoolClient> extends NeonQueryable {
    protected client: ClientT;
    constructor(client: ClientT);
    performIO(query: Query): Promise<Result<PerformIOResult>>;
}

declare type PerformIOResult = neon.QueryResult<any> | neon.FullQueryResults<ARRAY_MODE_ENABLED>;

export declare class PrismaNeon extends NeonWsQueryable<neon.Pool> implements DriverAdapter {
    private options?;
    private isRunning;
    constructor(pool: neon.Pool, options?: PrismaNeonOptions | undefined);
    getConnectionInfo(): Result<ConnectionInfo>;
    transactionContext(): Promise<Result<TransactionContext>>;
    close(): Promise<Result<undefined>>;
}

export declare class PrismaNeonHTTP extends NeonQueryable implements DriverAdapter {
    private client;
    constructor(client: neon.NeonQueryFunction<any, any>);
    performIO(query: Query): Promise<Result<PerformIOResult>>;
    transactionContext(): Promise<Result<TransactionContext>>;
}

declare type PrismaNeonOptions = {
    schema?: string;
};

export { }
